#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Jul  5 18:29:11 2020

@author: igor
"""
######  importando xarray
import xarray as xr
######  importando matplotlib
import matplotlib.pyplot as plt
######  importando numpy
import numpy as np
##########  pandas
import pandas as pd
######  importando cartopy
import cartopy.crs as ccrs
###### importando leitor para shape
from cartopy.feature import ShapelyFeature
from cartopy.io.shapereader import Reader
from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
###### importando plotar imagem de satelite
import cartopy.io.img_tiles as cimgt
###### importando 
from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

import matplotlib                                          # Comprehensive library for creating static, animated, and interactive visualizations in Python 
import tqdm                                                # A Fast, Extensible Progress Bar for Python and CLI
from matplotlib.animation import FuncAnimation, writers    # The easiest way to make a live animation in matplotlib 
from matplotlib.collections import LineCollection          # Allows one to plot multiple lines on a figure

plt.style.use('default')

class Streamlines(object):
    """
    Copyright (c) 2011 Raymond Speth.
    See: http://web.mit.edu/speth/Public/streamlines.py
    """

    def __init__(self, X, Y, U, V, res=2.00,
                 spacing=10, maxLen=700, detectLoops=False):
        """
        Compute a set of streamlines covering the given velocity field.
        X and Y - 1D or 2D (e.g. generated by np.meshgrid) arrays of the
                  grid points. The mesh spacing is assumed to be uniform
                  in each dimension.
        U and V - 2D arrays of the velocity field.
        res - Sets the distance between successive points in each
              streamline (same units as X and Y)
        spacing - Sets the minimum density of streamlines, in grid points.
        maxLen - The maximum length of an individual streamline segment.
        detectLoops - Determines whether an attempt is made to stop extending
                      a given streamline before reaching maxLen points if
                      it forms a closed loop or reaches a velocity node.
        Plots are generated with the 'plot' or 'plotArrows' methods.
        """

        self.spacing = spacing
        self.detectLoops = detectLoops
        self.maxLen = maxLen
        self.res = res

        xa = np.asanyarray(X)
        ya = np.asanyarray(Y)
        self.x = xa if xa.ndim == 1 else xa[0]
        self.y = ya if ya.ndim == 1 else ya[:,0]
        self.u = U
        self.v = V
        self.dx = (self.x[-1]-self.x[0])/(self.x.size-1) # assume a regular grid
        self.dy = (self.y[-1]-self.y[0])/(self.y.size-1) # assume a regular grid
        self.dr = self.res * np.sqrt(self.dx * self.dy)

        # marker for which regions have contours
        self.used = np.zeros(self.u.shape, dtype=bool)
        self.used[0] = True
        self.used[-1] = True
        self.used[:,0] = True
        self.used[:,-1] = True

        # Don't try to compute streamlines in regions where there is no velocity data
        for i in range(self.x.size):
            for j in range(self.y.size):
                if self.u[j,i] == 0.0 and self.v[j,i] == 0.0:
                    self.used[j,i] = True

        # Make the streamlines
        self.streamlines = []
        while not self.used.all():
            nz = np.transpose(np.logical_not(self.used).nonzero())
            # Make a streamline starting at the first unrepresented grid point
            self.streamlines.append(self._makeStreamline(self.x[nz[0][1]],self.y[nz[0][0]]))


    def _interp(self, x, y):
        """ Compute the velocity at point (x,y) """
        i = (x-self.x[0])/self.dx
        ai = i % 1

        j = (y-self.y[0])/self.dy
        aj = j % 1

        i, j = int(i), int(j)
        
        # Bilinear interpolation
        u = (self.u[j,i]*(1-ai)*(1-aj) +
             self.u[j,i+1]*ai*(1-aj) +
             self.u[j+1,i]*(1-ai)*aj +
             self.u[j+1,i+1]*ai*aj)

        v = (self.v[j,i]*(1-ai)*(1-aj) +
             self.v[j,i+1]*ai*(1-aj) +
             self.v[j+1,i]*(1-ai)*aj +
             self.v[j+1,i+1]*ai*aj)

        self.used[j:j+self.spacing,i:i+self.spacing] = True

        return u,v

    def _makeStreamline(self, x0, y0):
        """
        Compute a streamline extending in both directions from the given point.
        """

        sx, sy = self._makeHalfStreamline(x0, y0, 1) # forwards
        rx, ry = self._makeHalfStreamline(x0, y0, -1) # backwards

        rx.reverse()
        ry.reverse()

        return rx+[x0]+sx, ry+[y0]+sy

    def _makeHalfStreamline(self, x0, y0, sign):
        """
        Compute a streamline extending in one direction from the given point.
        """

        xmin = self.x[0]
        xmax = self.x[-1]
        ymin = self.y[0]
        ymax = self.y[-1]

        sx = []
        sy = []

        x = x0
        y = y0
        i = 0
        while xmin < x < xmax and ymin < y < ymax:
            u, v = self._interp(x, y)
            theta = np.arctan2(v,u)

            x += sign * self.dr * np.cos(theta)
            y += sign * self.dr * np.sin(theta)
            sx.append(x)
            sy.append(y)

            i += 1

            if self.detectLoops and i % 10 == 0 and self._detectLoop(sx, sy):
                break

            if i > self.maxLen / 2:
                break

        return sx, sy

    def _detectLoop(self, xVals, yVals):
        """ Detect closed loops and nodes in a streamline. """
        x = xVals[-1]
        y = yVals[-1]
        D = np.array([np.hypot(x-xj, y-yj)
                      for xj,yj in zip(xVals[:-1],yVals[:-1])])
        return (D < 0.9 * self.dr).any()

def update(frame_no):
    for i in range(len(lines)):
        lengths[i] += 0.05
        colors[i][:] = ((lengths[i]*1.5) % 1) 
        lines[i].set_color(colors[i])
    pbar.update()
    
# =============================================================================
# ######## abrir arquivo nc
# =============================================================================
ds = xr.open_dataset('/media/era5.nc')
##### definindo campo com duas dimensÃµes escolhendo um index
campo2D = ds.sel(time = '2016-01-04 00:00:00')
#### definindo lat lon em grade pelo numpy
lons2,lats2 = np.meshgrid(campo2D.longitude,campo2D.latitude)
# =============================================================================
# ####### plotagem de figura em branco
# =============================================================================
fig = plt.figure(figsize=(12,12))
ax = fig.add_subplot(1, 1, 1,projection=ccrs.PlateCarree())
# =============================================================================
# ###### plotagem de mapa
# =============================================================================
##### cortando para area desejada e colocando graus em x e y
# Select the extent [min.lon,min.lat,max.lon,max.lat]
extent =[-65.00,-40.0,-25.0,10.0]
# ax.set_extent(extent,crs=ccrs.PlateCarree())
ax.set_extent([extent[0], extent[2], extent[1], extent[3]], ccrs.PlateCarree())
# Define the image extent
img_extent = [extent[0], extent[2], extent[1], extent[3]] 

# =============================================================================
# ####### Gradeando o mapa
# =============================================================================
gl=ax.gridlines(crs=ccrs.PlateCarree(),
             draw_labels=True, #com grade
             linestyle='--', #grade tracejada
             linewidth=1, #espessura normal
             color='gray', #grade cinza
             alpha=0.5) #grade apagada
gl.xlines = False
gl.ylines = False
gl.top_labels = False
gl.right_labels = False
gl.xlabel_style = {'color': 'black', 'weight': 'bold','fontsize': 12}
gl.ylabel_style = {'color': 'black', 'weight': 'bold','fontsize': 12}

# =============================================================================
# ######## plotagem de vento e sua escala de cor ####################
# =============================================================================

U_200 = campo2D['u'].sel(level=200)
V_200 = campo2D['v'].sel(level=200) #definindo nivel
magnitude = np.sqrt((U_200**2) + (V_200**2)) #calculando magnitude
ucomp = U_200.to_numpy()
vcomp = V_200.to_numpy()
# Calculate the components
lats2_reverse = lats2[::-1]
ucomp=ucomp[::-1]
vcomp=vcomp[::-1]
Y, X = lats2_reverse, lons2
U, V = ucomp, vcomp

img1 = ax.contourf(lons2,lats2,magnitude, 
                  cmap='autumn_r',
                  levels=np.arange(30,90,10))
plt.clabel(img1, inline=1, inline_spacing=0, fontsize='10',fmt = '%1.0f', colors= 'black')
# =============================================================================
# #######  plotagem shape do brasil
# =============================================================================
mapa_amsul = ShapelyFeature(Reader('/media/amsulrp2.shp').geometries(),
                            ccrs.PlateCarree(),
                            edgecolor='gray',
                            facecolor='None',
                            linewidth=3)
ax.add_feature(mapa_amsul)
# =============================================================================
# ###########       definindo local e tamanho do cbar   ####################
# =============================================================================
# cbar.set_label('m/s', fontsize=20, fontweight='bold' ) #titulo do colorbar
plt.colorbar(img1, label='Wind Speed (m/s)', orientation='horizontal', pad=0.03, fraction=0.05)
# =============================================================================
# ###############     Titulo  ##################
# =============================================================================
plt.title('Wind (m/s) 200hPa  2016-01-04 00:00', fontsize=10, fontweight='bold')
#-----------------------------------------------------------------------------------------------------------
lengths = []
colors = []
lines = []
s = Streamlines(X, Y, U, V)

for streamline in s.streamlines:
    
    x, y = streamline
    
    # Points
    points = np.array([x, y]).T.reshape(-1, 1, 2)
    
    # Segments
    segments = np.concatenate([points[:-1], points[1:]], axis=1)
    n = len(segments)
    
    # Lenghts
    D = np.sqrt(((points[1:] - points[:-1])**2).sum(axis=-1))
    L = D.cumsum().reshape(n,1) + np.random.uniform(0,1)
    
    # Colors
    C = np.zeros((n,3))
    C[:] = ((L*1.5) % 1) 

    # Lines
    line = LineCollection(segments, linewidth=0.5, zorder=13)
   
    # Append lenghts, colors and lines
    lengths.append(L)
    colors.append(C)
    lines.append(line)
    ax.add_collection(line)

# Plot extent
ax.set_xlim(extent[0],extent[2]), ax.set_xticks([])
ax.set_ylim(extent[1],extent[3]), ax.set_yticks([])
plt.tight_layout()

#-----------------------------------------------------------------------------------------------------------
# Number of frames
n = 30
# Create the animation
animation = FuncAnimation(fig, update, frames=n, interval=20)
# Update the progress bar
pbar = tqdm.tqdm(total=n)
# Save animation as GIF
print("Generating the GIF...")
animation.save('/media/ladsin/IGOR06_64/ETAPA7/wind.gif', writer='imagemagick', fps=30)
# Close the progress bar
pbar.close()
# =============================================================================
# #################     Salvando imagem     #################################
# =============================================================================
# Open the GIF
print("Opening the GIF...")
from IPython.display import Image
Image(open('/media/wind.gif','rb').read())
